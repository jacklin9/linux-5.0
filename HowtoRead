ABOUT KBUILD

1. Start with top level Makefile. 
    At line 17, set the first target(default target) to be _all.
    At line 559, set target _all to depends on all. 
    At line 595, initialize init-y, drivers-y, net-y, libs-y, core-y, virt-y. 
    At line 611, set target all to depend on vmlinux (this is to be overriden by arch specific Makefile)
    At line 628, include arch/$ARCH/Makefile at line 628. The arch specific Makefile does following.
        At the beginning, set some arch specific variables
        At line 234, initializes header-y, and update libs-y, core-y, drivers-?
        At line 266, set target all to depend on bzImage, bzImage depend on vmlinux, and the command to
            generate bzImage based on vmlinux (see arch/x86/Makefile:271 for details).  Here one import 
            command is:
            $(Q)$(MAKE) $(build)=$(boot) $(KBUILD_IMAGE)
            This command run make -f scripts/Makefile.build obj=arch/x86/boot bzImage
    At line 1027, set vmlinux to depend on scripts/link-vmlinux.sh, $(vmlinux-deps), etc. The command is link-vmlinux.
    At line 1043, set targets in $(vmlinux-deps) to depend on $(vmlinux-dirs)
    At line 1052, set targets in $(vmlinux-dirs) to depend on prepare. Here the command run for each dir in $(vmlinux-dirs) is:
        $(Q)$(MAKE) $(build)=$@ need-builtin=1
        This command run make -f scripts/Makefile.build obj=dir need-builtin=1. The Makefile.build does some
        common init and include the Makefile in the dir (say init) and 


2. So from above we can see the workhorse is scripts/Makefile.build. Briefly speaking, this Makefile runs
    Makefiles in sub dirs and then compile files in obj dir. In detail:
    At line 9, set the first target(default target) to be __build
    At line 45, include obj/Kbuild or obj/Makefile if obj/Kbuild doesn't exist. Generally the Kbuild/Makefile
        set some variables to be used by this general Makefile
    At line 73, set target __build to depend on $(builtin-target) $(lib-target) $(extra-y)) $(subdir-ym) $(always)
    At line 397, set target $(subdir-obj-y) to depend on $(subdir-ym)
    At line 494, set the command of each target in $(subdir-ym) as:
        $(Q)$(MAKE) $(build)=$@ need-builtin=$(if $(findstring $@,$(subdir-obj-y)),1)
        So that each Makefile in subdir of obj will be run

3. File arch/x86/boot/Makefile is included by scripts/Makefile.build when running command at arch/x86/Makefile:271
    At line 80, set target bzImage to depend on setup.bin, vmlinux.bin
    At line 85, set target vmlinux.bin to depend on arch/x86/compressed/vmlinux
    At line 108, set target setup.bin to depend on setup.elf (built from files in arch/x86/boot/{header.S,....})
    At line 111, set arch/x86/compressed/vmlinux to be generated with command:
        $(Q)$(MAKE) $(build)=$(obj)/compressed $@
        In file arch/x86/compressed/Makefile
        At line 115, set target vmlinux to depend on arch/x86/compressed/{vmlinux.lds,head_64.,misc.o,piggy.o, etc} 
        At line 157, set target piggy.S to depend on vmlinux.bin
        At line 119, set vmlinux.bin to depend on *file* vmlinux
4. The structure of the kernel image is as follows:
    +------------------------------+--------------------------------------------+------------------------------------------------+
    |           setup              |                    head                    |                   piggy (Compressed)           |
    |(arch/x86/boot/header.S, etc) |(arch/x86/boot/compressed/head_64.S, etc)   |  vmlinux(arch/x86/kernel/head_64.S, etc)       |
    |       Real mode code         |                                     Protected code (loaded at 1M)                           |
    +------------------------------+--------------------------------------------+------------------------------------------------+
    See https://developer.ibm.com/articles/l-linuxboot/ for boot process.
    See document Documentation/x86/boot.txt for boot protocol

	Real mode code can be loaded anywhere under 1M (the lower the better to avoid BIOS data) because it can be relocated by setting CS, DS correctly. Generally real mode code does 2 things:
	a. copy boot parameters
	b. setup GDT, switch to protected mode and jump to protected code
	Note that a boot loader may ignore the real mode code and load protected code directly.

	Protected code is also relocatable and thus can be loaded anywhere above 1M. It does following things:
	a. Enable 4 level paging long mode
	b. Enable 5 level paging long mode with the help of trampoline
	c. Does relocation
	d. Move itself to a safe place and decompress the vmlinux image
	e. Relocate the decompressed vmlinux image and jump to it
	Note that the protected code consists of two parts: 1. the 32 bit code without paging; 2. 64 bit code. A boot loader may ignore the 32 bit part and jump to 64 bit directly.
5. So start reading kernel code from file arch/x86/boot/header.S. This should be read together with setup.ld
6. arch/x86/boot/header.S contains two parts:
    Code from line 51 to line 287 is the boot sector. This sector contains two information:
    1. If it is built for EFI, it contains PE header so that EFI boot can load the kernel
    2. If it is not built for EFI, it contains a small stub to print error message if it is loaded by a non-compatible loader
    This part also contains some fields filled by build.c. These fields will be used by the second part.

    Code from line 289 is the real entry point of the startup code. This file does some real mode init and
    go to arch/x86/boot/compressed/head_64.S
7. arch/x86/boot/compressed/head_64.S. This file should be read together with arch/x86/boot/compressed/vmlinux.lds.S.
    Now %esi contains the boot_params. Start running at arch/x86/boot/compressed/head_64.S:48. It does some
    64bit paging initialization, move itself to a configured place and decompress the piggy part and jump to
    it (arch/x86/kernel/head_64.S:55)
    The compressed kernel image (ZO), has been moved so that its position
    is against the end of the buffer used to hold the uncompressed kernel
    image (VO) and the execution environment (.bss, .brk), which makes sure
    there is room to do the in-place decompression. (See header.S for the
    calculations.)
    
                                |-----compressed kernel image------|
                                V                                  V
    0                       extract_offset                      +INIT_SIZE
    |-----------|---------------|-------------------------|--------|
                |               |                         |        |
               VO__text      startup_32 of ZO          VO__end    ZO__end
                 ^                                         ^
                 |-------uncompressed kernel image---------|

8. The real kernel is generated by linking the following.
    init-y		:= init/
    drivers-y	:= drivers/ sound/ firmware/
    net-y		:= net/
    libs-y		:= lib/
    core-y		:= usr/
    virt-y		:= virt/
    -------------------------------------------
    head-y := arch/x86/kernel/head_$(BITS).o
    head-y += arch/x86/kernel/head$(BITS).o
    head-y += arch/x86/kernel/ebda.o
    head-y += arch/x86/kernel/platform-quirks.o

    libs-y  += arch/x86/lib/

    core-y += arch/x86/

    ===========================================
    vmlinux-deps := arch/$(SRCARCH)/kernel/vmlinux.lds      $(head-y) $(init-y)      $(core-y) $(libs-y2) $(drivers-y) $(net-y) $(virt-y))      $(libs-y1)
9. The real kernel starts running at arch/x86/kernel/head_64.S:55. This should be read together with file 
    arch/x86/kernel/vmlinux.lds.S. This file calls arch/x86/kernel/head64.c, which in turn calls start_kernel 
    at init/main.c:537.

10. Trap handler is initialized in function trap_init:
	1. call function idt_setup_traps to fill the IDT table with a table in arch/x86/kernel/idt.c:74. Symbols here are defined in file arch/x86/entry/entry_64.S starting from line 970
	2. call function cpu_init, which in turn calls function syscall_init. This function fills the addr of syscall entry(entry_SYSCALL_64) into MSR register MSR_LSTAR. entry_SYSCALL_64 eventually calls functions in table sys_call_table whose content is defined in file arch/x86/entry/syscalls/syscall_64.tbl
11. Interrupt handler is initialzed in function init_IRQ. The function calls x86_init.irqs.intr_init, which is actually native_init_IRQ. This function calls idt_setup_apic_and_irq_gates. This function fill idt_table with table apic_idts and table irq_entries_start

12. When kernel init is almost done, kernel create a kernel thread running kernel_init, and another kernel thread running kthreadd, and jump to do_idle

Initialization Process Explained
1. KERNEL STACK: at arch/x86/kernel/head_64.S:77, set stack to be the end of init task kernel stack
2. PAGE MAPPING: in function __startup_64, use early_top_pgt to set up kernel virtual addr space mapping and identical mapping of physical mem used by kernel. In kernel virtual addr mapping, pages used by all other levels are statically allocated; in identical mapping, allocate pages in early_dynamic_pgts pool which is in section .init.data
3. KERNEL STACK: at arch/x86/kernel/head_64.S:171, set stack to be the end of init task kernel stack again
4. PAGE MAPPING: set gdt by using early_gdt_descr which points to per-cpu gdt
5. PAGE MAPPING: in function __x86_64_start_kernel, call reset_early_page_tables to clear the identical mapping and reset early_dynamic_pgts pool
6. PAGE MAPPING: in function __x86_64_start_kernel, call clear_page to clear init_top_pgt
7. KASAN & PAGE MAPPING: in function __x86_64_start_kernel, call kasan_early_init to add statically allocated page kasan_early_shadow_page to both early_top_pgt and init_top_gdt
8. IDT: in function __x86_64_start_kernel, call idt_setup_early_handler to fill idt_table with early_idt_handler_array which processes page fault exception seariously and ignores other exceptions (calls early_fixup_exception)
9. PAGE MAPPING: at x86_64_start_kernel:465, fill init_top_gdt with kernel virtual addr mapping
10. KERNEL STACK: in start_kernel, call set_task_stack_end_magic to fill the end of init task kernel stack with stack protector value 
11. DEBUG: in start_kernel, call debug_objects_early_init to init obj_hash which is a hashlist of debug_obj, and init linked list obj_pool by adding debug_obj in obj_static_pool
12. CGROUP: in start_kernel, call cgroup_init_early to init cgrp_dfl_root(cgroup tree root) and cgroup_subsys(subsys list)
13. IDT: at start_kernel:548, disable IRQ
14. SMP: in startup_kernel, call boot_cpu_init to mark boot CPU online, active, present, possible
15. MEM MANAGE: in setup_arch, call memblock_reserve to add mem region occupied by kernel to memblock.reserved
16. MEM MANAGE: in setup_arch, call memblock_reserve to add first page to memblock.reserved
16. MEM MANAGE: in setup_arch, call early_reserve_initrd to add initrd to memblock.reserved
17. IDT: in setup_arch, call idt_setup_early_traps to fill idt_table with entries in table early_idts. This table contains 2 entries, one(entry debug) for handling debug exception, the other(entry int3) for handling breakpoint exception
18. PAGE MAPPING: in setup_arch, call early_ioremap_init:
	1. Call early_ioremap_setup to to init slot_virt array which stores starting virtual address of each fix slot (8 slots, each slot have 64 pages)
	2. Clean up statically allocated page bm_pte and install the page bm_pte to an pmd entry according to the starting virtual addr of fixmap
19. MEM MANAGE: in setup_arch, call e820__memory_setup to copy e820 table to e820_table and resolve overlap and type conflicts. The function also copies e820_table to e820_table_kexec and e820_table_firmware
20. MEM MANAGE: in setup_arch, init init_mm from line 925 to 930
21. CONFIG: in setup_arch, call parse_early_param to init all variables with early = true registered by macro early_param
22. MEM MANAGE: in setup_arch, call memblock_x86_reserve_range_setup_data to add ranges used by setup_data in boot params to memblock.reserved
23. MEM MANAGE: in setup_arch, call e820__reserve_setup_data to add ranges used by setup_data in boot params to e820_table, e820_table_kexec
24. TIME: in setup_arch, call tsc_early_init to initialize cpu_khz and tsc_khz, loops_per_jiffy 
25. MEM MANAGE: in setup_arch, call e820_add_kernel_range to make sure physical mem used by kernel is covered by e820_table and marked as ram. If not, remove the kernel range from e820_table and add it to the table again. Then setup_arch calls trim_bios_range to make sure first page is reserved in e820_table, [640k, 1M] is not in e820_table. trim_bios_range also call e820__update_table to sanitize the table
26. MEM MANAGE: in setup_arch, call early_gart_iommu_check to detect graphical card mem and add it to e820_table as reserved mem and then sanitize the e820_table
27. SMP & MEM MANAGE: in setup_arch, call find_smp_config to find the addr of smp config table, store the addr to mpf_base, and reserve mem of the table (add the region to memblock.reserved)
28. PAGE MAPPING & MEM MANAGE: in setup_arch, call early_alloc_pgt_buf to enlarge brk section and init pgt_buf_start, pgt_buf_end to the start of brk, and pgt_buf_top to end of the enlarged brk. then call reserve_brk to put the enlarged brk region to memblock.reserved
29. MEM MANAGE: in setup_arch, call memblock_set_current_limit to set memblock.current_limit to 1M
30. MEM MANAGE: in setup_arch, call e820__memblock_setup to allow changing memblock.memory and memblock.reserved size, and add ram regions and kernel mem region in e820_table to memblock.memory. Then call reserve_bios_regions to add bios mem to memblock.reserved
31. MEM MANAGE: in setup_arch, call reserve_real_mode to figure out the size of real mode blob and allocate mem under 1M, put the region to memblock.reserved, and set real_mode_header to the beginning of the region. Then call trim_platform_memory_ranges and trim_low_memory_range to add some special mem ranges to memblock.reserved
32. PAGE MAPPING: in setup_arch, call init_mem_mapping to set pti_mode and cpu capability(like PSE, PEG, in function pti_check_boottime_disable), set page_size_mask(in function probe_page_size_mask), set PCID(in function setup_pcid), map phy addr [0, 1M) to [PAGE_OFFSET, PAGE_OFFSET + 1M) in init_mm.pgd that is swapper_pg_dir which is defined as init_top_pgt(in function init_memory_mapping), set trampoline_pgd_entry(in function init_trampoline), map phy addr [1M, kernel_end) and [kenrel_end, mem end)(by calling function memory_map_bottom_up). During these mappings, required page mem is allocated in brk section if brk can be used, otherwise memblock is used, and variable nr_pfn_mapped and pfn_mapped are updated according to the mapped ranges
33. IDT: in setup_arch, call idt_setup_early_pf to set X86_TRAP_PF entry in idt_table to be function page_fault(arch/x86/entry/entry_64.S:1143)
34. PRINT: in setup_arch, call setup_log_buf to dynamically allocate log_buf in memblock, update log_buf_len, and copy old buf content to the new one
35. FS & MEM MANAGE: in setup_arch, call reserve_initrd to make sure mem used by initrd is mapped and set initrd_start and initrd_end 
36. ACPI: in setup_arch, call acpi_table_upgrade to find all ACPI tables in initrd, store them in acpi_initrd_files, allocate mem for ACPI table in memblock and store addr in acpi_tables_addr, and copy ACPI tables to acpi_tables_addr
37. SMP: in setup_arch, call vsmp_init to check if the box support ScaleMP vSMP (set is_vsmp), and if vSMP is supported, set x86_platform.apic_post_init to vsmp_apic_post_init, set setup_max_cpus(by calling vsmp_cap_cpus)
38. ACPI & SMP & DMI: in setup_arch, call acpi_boot_table_init
